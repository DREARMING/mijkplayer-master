GSY

视频画面的比例

展示视频画面的 View 的Measure宽高

无论如何，我们都要尽量确保遵循 视频画面的比例，否则会拉伸画面，造成很难看，所以测量之后的大小应该 遵守视频画面的比例。


关于 GSYVideoType 的参数解析

SCREEN_TYPE_DEFAULT 要求 SurfaceView 或者Textview的 大小 按照 视频的比例显示 ： mVideoWidth/ mVideoHeight，
测量的宽高根据这个画面比例去决定具体的宽高。


TextureView 可以通过 getBitmap 方法获取当前 Texture 绘制的画面，也就是播放器端的视频截帧功能。

关于像斗鱼这种，可以在列表界面显示当前直播画面的 图，
虽然不是及时的图，可能几分钟刷新一次，这个功能应该是 主播推流到服务器，服务器在解码过程中，通过定时器功能，获取视频画面并且存放起来。播放端将会通过websocket或者轮询的方式，也可以刷新时，拿到当前直播画面(延时)

对于SurfaceView 的话，原理是一样的，SurfaceView 和 TextureView 不同之处在于，SurfaceView 是在当前窗口界面开了一个洞，显示下面的窗口，而视频渲染就是画在 Surfaceview自己的窗口上。因为是独立的缘故，没法像其他View那样，对平移、动画、透明度等做处理。
而 TextureView 却像普通的View 一样，可以进行平移缩放，因为TextureView 没有新建窗口，而是在原窗口上，通过硬件加速来绘制视频画面。

SurfaceView 获取视频画面只需获取 canvas 即可，利用canvas 就可以画当前帧了。


笃学楼4楼403
http://192.168.1.164


问题：会出现累积延迟，播的越久，延迟时间越大

原因：播放器解码速度好像跟不上，另外，摄像头会缓存

尝试：


硬解容易花屏、卡住

测试情况：

软解 - 同帧率与max_fps的情况：6分钟累计延迟 - 6秒, 1920x1086 25fps 动态帧率
软解 - 同帧率与max_fps，8分钟-7秒延迟， 1920x1086 25fps 固定帧率 - an - audio unable




如果添加 max_cache_duration 的话，可以确保 在 pktQueue 中缓存的pkt duration 最大为 max_cache_duration，因为总的延迟最大就是网络延迟 + max_cache_duration 了

降码率可以减少网络延迟和解码器的压力

累积延迟的原因有：
1. 解码器的解码速度跟不上推流的码率。解决办法：降低码率？降低帧率？
2. 网络抖动，网络突然慢了下来，导致网络延迟过高，然后又好了，因为是tcp连接，包都会依序到达，而不会丢掉pkt，所以一旦网络慢下来，或者网络差的时候，那么就会永远比推流慢了

max_cache_duration 可以解决的情况：
1. 可以网络抖动的情况下，导致 pkt_queue 里面缓存的数据之间的时长不超过max_cache_duraion，避免抖动引起的延迟累加，并且有可能造成内存占用过高、oom的情况；
2. 可以缓解在解码器跟不上推流时造成的累积延迟，如果

方案：

//判断关键帧
if (pkt.flags & AV_PKT_FLAG_KEY) {
    av_packet_unref(&pkt);
    break;
}

解码之后，才能判断是否是 b帧或者p帧，所以不能从这里入手了。

在读取到关键帧时，判断第一个pkt和最后一个pkt的 pts*time_base 相差多少，如果大于max_cache_duration，就 flush pkt_queue?
能否不一次性清除一组 gop 呢?而是适当抛弃一些b帧、p帧


解码速度不如推流速度的计算方法是，
pktQueue的添加速度和减少速度的差异-- 要考虑对于flush对计算的影响

对于解码器性能较低的时候，有什么优化措施吗？
1. 降码率降帧率
2. 丢帧

确认代码逻辑：
当有音频的时候，如果解码器性能跟不上、会出现视频追音频的情况，跟不上就有可能造成音画不同步了。会不会有另外一种可能，音频和视频相差太大，会卡住？
如果只有视频时，同步方案是怎么样的？
直播流的情况下，以外部时钟作为主时钟。



添加指定主时钟option的功能
对于暂停之后，再次播放需要重新加载。





对于主时钟的选择问题，

因为默认的主时钟是音频，如果音频流不存在的时候，那么主时钟是外部时钟

如果设置了主时钟是视频，那么如果视频流不存在的话，那么主时钟会设为音频

其他情况主时钟是外部时钟（System）



对于非音频作为主时钟时

1. 以外部时钟作为主时钟 -- 外部时钟的时钟应该一直为时间显示第一帧后到现在的时间。期间如果发生暂停的情况？
	1. 播放直播流时，视频帧显示之前，都会调用一次系统时间，并且更新一下外部时钟和 clock_speed。
		如果不是直播流，外部时钟应该是没有任何作用的才对。正常的视频播放，用音频作为主时钟就够了。没有音频，就视频自己作为主时钟。
	2. 

1. 音频要进行重采样处理，通过对样本数量进行调节，就可以控制音频时间了。
2. 外部时钟作为主时钟时，

对于音频作为主时钟。









同步外部时钟：
假设第一次外部时钟的pts = 0，lastupdate 是刚刚播放的时间。。

当视频做同步的时候，对比外部时钟，如果上一帧还没有显示完，那么继续显示
如果上一帧显示完了，显示当前帧，那么就更新视频时钟，同时将视频时钟的时间设置为外部时钟的pts



1. 丢帧策略：

=========================================================================

只存在视频流的情况

以视频流作为主时钟的话：

网络卡顿必然发生，它将会导致什么呢？

1. 获取的pkt之间的pts跟不上外部时钟的时间，有时候是一个pkt，有时候是多个pkt，ijk这种情况会导致什么样的后果：
frame_timber 的时间如果不超过100ms的话，是正常的，但是超过100ms之后，会被强制同步成当前时间，那么frame_timer + delay >time，导致不丢帧，从而产生延迟，这是在要求画面正常不卡顿时候的正确措施，如果对实时性要求比较高的话，就会产生累积延迟的效果。

所以这里的处理策略是：
1. 对于点播的话，那么必然不能够丢帧，一切由画面流畅度决定
2. 对于直播，可以选择丢帧
	1. 目前已知的丢帧可以在网络获取到pkt之后，马上丢掉，不选择放进解码器中。
		1. 这种方案下，要注意对于h264的I和P和B三大类型的帧处理，I帧不能丢弃，否则后面一组gop就不能解了，B帧可以随意丢弃，但是pkt里面判断不出谁是P谁是B，所以不能在这里处理，只能判断出是否是I帧，这么导致的后果直接就是，是否要丢弃一组GOP，如果GOP的间隔比较大的话，那么挺危险的，将会丢掉很长一段时间的视频，导致严重的卡顿。最好控制gop的密度。
	2. 如果显示线程里面进行丢帧处理的话，如何做？个人觉得，这种方式下，只要让pts跟随着外部时钟，那么网络卡顿，自然会慢慢通过丢帧，跟上去。如果间隔相差较大，那么显示帧的速度依赖于 解码器的速度，解码器不可能跟上速度的，这样就不会产生一下子跳一组gop这种夸张的卡顿，就是有点跳帧的感觉。最终会追上去的。
		1. 对于这种丢帧策略，有个比较大的问题就是，如果卡顿的时间超过好几秒，那么这种跳帧的感觉就会延长，感觉用户体验来说，不怎么好。
			1. 个人感觉，当卡顿时间超过一定时间比例，采样方案1去读取数据，再丢帧，还是直接断线重连呢？
				1. 方案1丢帧，因为是tcp的， av_read_frame 总是顺序到达，没办法直接获取最新一帧，这也代表着还是要通过网络去获取旧的数据帧，从而再丢弃。
				2. 超过一定时间也可以直接让播放器重新连接，直接报网络不佳，让用户点击刷新，或者直接重新加载，然后刷新。这个有必要对重新建立一个播放器，再获取到最新帧会消耗多少时间。
				3. 也可以通过暂停并显示buffer的方式，让其加载到最新帧后，直接跳到最新的一帧。
					1. 暂停也要统计超时，如果暂停之后，许久没有缓存到足够的帧，就失败。让用户刷新，直接重连。

感觉还是方案2优秀。gop不一定是可控的。对于短暂的卡顿，用丢帧方式追就好，不用一组gop去丢。
所以策略是：
1. 先设定主时钟为外部时钟，这样，就可以避免短暂的网络抖动导致追不上去。 --- 这里最好提供一种选择途径，是质量有限，还是降低延迟
2. 如果网络抖动时间过长，几秒内的网络都很差，那么就作暂停处理，触发buffer，然后开始不断下载 pkt，直到读取到的 pkt ，是关键帧并且跟当前时钟相差不大于阈值，那么清空 pkt 队列，并且添加flush_pkt，让解码器和显示线程丢弃那些没用的数据。
	avformat_seek_file 测试一下seek 可能性

3. 如果操作2的时长超过指定阈值，那么就需要报错了，提供界面给用户去刷新重连。

=========================================================================

只存在音频流的情况
以音频作为主时钟，不卡顿即可，不丢帧，否则人耳听起来就会很卡的感觉。不过音频具备重采样的策略，可以追外部时钟。
那么让他自己正常播放就好了，累积延迟也可以了接受。

===========================================================================


音频和视频都存在的情况
这种情况，默认都是以音频作为主时钟，

对于点播的话，其实没有延迟这一说法，就老老实实按照 音频作为主时钟播放即可，保证质量优先。网络不好也没关系，网络好之后正常播放即可。
如果网络实在太差了，buffer太长时间了，那就是显示播放错误就好，让用户重新播放。


对于直播：
对于这种情况，等于只有视频流的情况，但是主时钟却变成了音频时钟，那么这里会发生什么呢？

音频作为主时钟，暂停之后，恢复，时间戳还是以前的时间戳，这个是不会变的，永远跟随着pts变化.
也就说，如果网络抖动的话，那么下一帧的pts慢到来的话，因为视频在等音频，音频等网络抖动，造成累积延迟，最好是通过倍速的手法去追上延迟。

最后的方案就是跟只有视频流的一样了，让音频追外部时钟，小于一定阈值，用重采样去追，不过重采样的发生是不能自身调用的，是主时钟不是音频时钟时发生的。
如果网络抖动，或者网络太差，就采用 缓存，先缓存到最新pkt，然后再丢帧。。取消buffer，继续播放。
如果缓存超时，那么提供手段去让用户重新点播放。

-- 是否可以提高音频的播放速率，因为视频时紧跟音频的，而音频如果与外部时钟相差大于某个阈值，就让音频来追外部时钟呢？直到与外部时钟相差小于某个阈值，这样可以避免小范围内的抖动，不用强行丢一组关键帧。  ffp_set_playback_rate 是调整播放速率的。


在外部时钟作为主时钟的时候，对于 video_refresh 函数中的 check_external_clock_speed(is) 方法，内部对 pkt_queue 缓存的pkt数量去调节外部时钟的速度。
这样点播的时候比较有用，可以有效缓解短暂的网络抖动带来的影响，可以让视频更加平滑。

但是如果在直播的话，如果以外部时钟作为主时钟，在网络抖动时，因为一开始网络不好，导致外部时钟速度调慢了，当网络恢复之后，因为这时候视频时钟已经超过了外部时钟，因为外部时钟变慢了，所以会delay>0, time-frame_timber > 100ms， 导致frame_timber 被更新，这样就会被强制同步为当前时间，网络变好之后获取的pkt，很多是过时的，从而导致了累积延迟。 
所以这里可以考虑的措施是：对于直播时，在网络抖动时，即使 pkt_queue 没有多少 pkt，但是对时钟不要进行调慢，按照原有速度即可。这样子，就可以保证外部时钟是正常速度，网络恢复之后，不会被更新 frame_timber.


不过外部时钟有个比较好的点就是，当 pkt_queue 的 pkt数量大于10，那么就会加快外部时钟，因为它认为播放太慢了，有利于直播的时候，追上延迟。




1. 提供 option 让 java 层决定是否启用质量优先还是低延迟。
2. 只有在低延迟的选项为 true 时，才决定启用优化方案。
3. 判断是否只有视频流，如果只有视频流，并且是低延迟的时候，设置主时钟为 外部时钟 -- 并且在 video_refresh 方法里面，在检测外部时钟速度时，对于低延迟的情况，外部时钟在pkt数量不足时，不能降低速度。
4. 如果音视频流都有的情况下，不能更改时钟，避免音画不同步，这里如果网络卡顿的话，音画也不会不同步，问题就在于累积延迟的问题，
	这里最好设置一个阈值，当累积延迟大于该阈值时，触发buffer并暂停，然后开始丢帧，丢到最邻近的关键帧，然后停止buffer，并开始播放
5. 当4超过一定时间都无法获取到数据帧，那么结束播放，提示用户播放失败，让他有机会自己去重连。

目前存在的问题：
1. packet-buffer duration 不准确的问题。等待好长时间才能关闭
2. infinite buffer


3. analyzeduration 和 probeSize 不设置大一点的话，很容易造成黑屏无声。最惨的就是 analyzeduration 它的值更为重要。
但是弥补不了，因为无法捉到 这两个参数达到了临界条件。无法进行重试操作。

4. 关于下载速度的获取？
方案1，需要在 read_thread 方法中做统计，怎么统计呢？
当触发buffer之后，因为 packet_buffer 会 50ms或者 500ms 检查一下buffer的情况，这个时候也可以上传msg到java层，告诉当前的下载速度。
下载速度的统计，buffer开始之后，记录时间，开始叠加每一此循环pkt的pktdata 大小，上传一次，清空1次？buffer结束之后，清空统计。

方案2 ：底层ffmpeg的 tcp文件。






最终方案：
1. 低延迟 low_delay option 提供。该 options 应用于直播，非直播不要添加该 options，添加该 option 播放器会启用一系列策略去降低延迟。以保证实时性
2. 对于直播流的处理，当没有音频流时，需要将主时钟设置为 外部时钟
3. 对于直播的处理，在视频播放的函数 video_refresh, 会同步外部时钟的速度，外部时钟会判断 pkt 的数量 去决定是否要调度外部时钟，如果 pkt 数量多，就加快点，pkt数量少，就慢点。这个对于降低延迟来说是不合理的，在pkt数量少的时候，不能慢下来，保持正常速度才是正确的。这样可以确保真实的时间一直大于pts，不会出现 网络抖动之后，因为外部时钟慢下来，导致 frame_timber 被强制同步，这样就没法快速丢帧追上去了。 所以在调整外部时钟速度的函数需要处理这种情况
4. 对于 read_thread 函数的改动。在 low_delay == 1时，
如果只有视频的情况，因为交由视频主时钟去处理了，所以这里不用对这种情况进行处理，主要是针对音频和视频都存在的情况进行处理。







任务列表：
1. 直播课堂app，部分流不能播的问题
2. 班牌需要与后台协商密钥，阻止通过浏览器的方式进入班牌，而是必须从 班牌进入网页。
3. 给班牌添加获取系统时长+内存等系统信息。
